name: Auto-fill PR Template

on:
  pull_request:
    types: [opened, synchronize, reopened, edited]

jobs:
  auto-fill-template:
    name: Auto-fill PR Template
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Need full history for commit analysis
      
      - name: Analyze PR changes
        id: analyze
        run: |
          BRANCH="${{ github.head_ref }}"
          BASE="${{ github.base_ref }}"
          
          # Determine change type from branch name
          if [[ "$BRANCH" =~ ^feature/ ]]; then
            echo "type=feature" >> $GITHUB_OUTPUT
            echo "checked_item=Feature" >> $GITHUB_OUTPUT
            echo "checkbox_index=0" >> $GITHUB_OUTPUT
            CHANGE_TYPE="Feature"
          elif [[ "$BRANCH" =~ ^fix/ ]]; then
            echo "type=bug" >> $GITHUB_OUTPUT
            echo "checked_item=Bug fix" >> $GITHUB_OUTPUT
            echo "checkbox_index=1" >> $GITHUB_OUTPUT
            CHANGE_TYPE="Bug fix"
          elif [[ "$BRANCH" =~ ^docs/ ]]; then
            echo "type=documentation" >> $GITHUB_OUTPUT
            echo "checked_item=Documentation" >> $GITHUB_OUTPUT
            echo "checkbox_index=2" >> $GITHUB_OUTPUT
            CHANGE_TYPE="Documentation"
          elif [[ "$BRANCH" =~ ^refactor/ ]]; then
            echo "type=refactor" >> $GITHUB_OUTPUT
            echo "checked_item=Refactoring" >> $GITHUB_OUTPUT
            echo "checkbox_index=3" >> $GITHUB_OUTPUT
            CHANGE_TYPE="Refactoring"
          elif [[ "$BRANCH" =~ ^chore/ ]]; then
            echo "type=chore" >> $GITHUB_OUTPUT
            echo "checked_item=Other (please describe)" >> $GITHUB_OUTPUT
            echo "checkbox_index=4" >> $GITHUB_OUTPUT
            CHANGE_TYPE="Chore"
          else
            echo "type=other" >> $GITHUB_OUTPUT
            echo "checked_item=" >> $GITHUB_OUTPUT
            echo "checkbox_index=-1" >> $GITHUB_OUTPUT
            CHANGE_TYPE="Other"
          fi
          
          # Extract issue number from branch name (e.g., fix/123-description or feature/456-name)
          if [[ "$BRANCH" =~ /([0-9]+)- ]]; then
            ISSUE_NUM="${BASH_REMATCH[1]}"
            echo "issue_number=$ISSUE_NUM" >> $GITHUB_OUTPUT
            echo "has_issue=true" >> $GITHUB_OUTPUT
          else
            echo "issue_number=" >> $GITHUB_OUTPUT
            echo "has_issue=false" >> $GITHUB_OUTPUT
          fi
          
          # Get changed files
          CHANGED_FILES=$(git diff --name-only origin/$BASE...HEAD 2>/dev/null || git diff --name-only HEAD~1...HEAD 2>/dev/null || echo "")
          echo "changed_files<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGED_FILES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          # Check if markdown files changed
          if echo "$CHANGED_FILES" | grep -qE '\.(md|mdx)$'; then
            echo "has_markdown=true" >> $GITHUB_OUTPUT
          else
            echo "has_markdown=false" >> $GITHUB_OUTPUT
          fi
          
          # Get commit messages for description
          COMMIT_MSGS=$(git log origin/$BASE..HEAD --pretty=format:"%s" 2>/dev/null || git log HEAD~5..HEAD --pretty=format:"%s" 2>/dev/null || echo "")
          echo "commit_messages<<EOF" >> $GITHUB_OUTPUT
          echo "$COMMIT_MSGS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          # Check if commits follow conventional commits format
          if echo "$COMMIT_MSGS" | head -1 | grep -qE '^(feat|fix|docs|chore|refactor|style|test|build|ci|perf|revert)(\(.+\))?:'; then
            echo "conventional_commits=true" >> $GITHUB_OUTPUT
          else
            echo "conventional_commits=false" >> $GITHUB_OUTPUT
          fi
          
          # Generate description from branch name
          BRANCH_DESC=$(echo "$BRANCH" | sed 's|^[^/]*/||' | sed 's/-/ /g' | sed 's/\b\(.\)/\u\1/g')
          echo "branch_description=$BRANCH_DESC" >> $GITHUB_OUTPUT
      
      - name: Auto-fill PR template
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = context.payload.pull_request.number;
            const branchName = '${{ github.head_ref }}';
            const checkboxIndex = parseInt('${{ steps.analyze.outputs.checkbox_index }}') || -1;
            const issueNumber = '${{ steps.analyze.outputs.issue_number }}';
            const hasIssue = '${{ steps.analyze.outputs.has_issue }}' === 'true';
            const hasMarkdown = '${{ steps.analyze.outputs.has_markdown }}' === 'true';
            const conventionalCommits = '${{ steps.analyze.outputs.conventional_commits }}' === 'true';
            const branchDescription = '${{ steps.analyze.outputs.branch_description }}';
            const commitMessages = `${{ steps.analyze.outputs.commit_messages }}`;
            
            // Get current PR body
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            
            let body = pr.body || '';
            // Normalize line endings to \n (GitHub API may return \r\n)
            body = body.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
            let updated = false;
            
            // 1. Auto-fill Type of Change checkbox
            if (checkboxIndex >= 0) {
              const checkboxes = [
                'Feature',
                'Bug fix',
                'Documentation',
                'Refactoring',
                'Other (please describe)'
              ];
              
              const targetCheckboxText = checkboxes[checkboxIndex];
              console.log(`Target checkbox: ${targetCheckboxText} (index: ${checkboxIndex})`);
              
              // First, uncheck all other checkboxes in the Type of Change section
              for (let i = 0; i < checkboxes.length; i++) {
                const checkboxText = checkboxes[i];
                if (i !== checkboxIndex) {
                  // Uncheck this checkbox if it's checked
                  const checkedPattern = new RegExp(
                    '-\\s*\\[x\\]\\s*' + checkboxText.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\s*(<!--[^>]*-->)?',
                    'g'
                  );
                  if (body.match(checkedPattern)) {
                    body = body.replace(checkedPattern, (match) => {
                      return match.replace(/\[x\]/, '[ ]');
                    });
                    updated = true;
                    console.log(`✅ Unchecked: ${checkboxText}`);
                  }
                }
              }
              
              // Now check the target checkbox if it's not already checked
              const alreadyChecked = body.includes('[x] ' + targetCheckboxText) || 
                                    body.includes('[x]' + targetCheckboxText) ||
                                    body.match(new RegExp('-\\s*\\[x\\]\\s*' + targetCheckboxText));
              
              if (!alreadyChecked) {
                // Find and check the target checkbox - use line-by-line approach for reliability
                const escapedText = targetCheckboxText.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                const searchPattern = '- [ ] ' + targetCheckboxText;
                
                console.log(`Looking for pattern: ${searchPattern}`);
                console.log(`Pattern exists: ${body.includes(searchPattern)}`);
                
                if (body.includes(searchPattern)) {
                  // Split into lines and find the matching line
                  const beforeReplace = body;
                  const lines = body.split('\n');
                  let found = false;
                  
                  for (let i = 0; i < lines.length; i++) {
                    // Check if this line contains the unchecked checkbox pattern
                    if (lines[i].includes(searchPattern)) {
                      // Make sure it's not already checked
                      if (!lines[i].includes('[x] ' + targetCheckboxText) && !lines[i].includes('[x]' + targetCheckboxText)) {
                        const originalLine = lines[i];
                        // Replace [ ] with [x] in this line
                        lines[i] = lines[i].replace(/\[ ?\]/, '[x]');
                        found = true;
                        console.log(`Found line ${i}: ${originalLine.substring(0, 60)}...`);
                        console.log(`Replaced to: ${lines[i].substring(0, 60)}...`);
                        break;
                      } else {
                        console.log(`Line ${i} already has checkbox checked: ${lines[i].substring(0, 60)}...`);
                      }
                    }
                  }
                  
                  if (found) {
                    body = lines.join('\n');
                    const changed = beforeReplace !== body;
                    console.log(`Body changed: ${changed}`);
                    console.log(`Before length: ${beforeReplace.length}, After length: ${body.length}`);
                    console.log(`Before starts with: ${beforeReplace.substring(0, 50)}`);
                    console.log(`After starts with: ${body.substring(0, 50)}`);
                    if (changed) {
                      updated = true;
                      console.log(`✅ Auto-checked type checkbox: ${targetCheckboxText}`);
                      console.log(`Updated flag set to: ${updated}`);
                    } else {
                      console.log(`⚠️  Line replaced but body didn't change - possible issue`);
                      // Force update anyway if we found and replaced the line
                      updated = true;
                      console.log(`⚠️  Forcing updated=true since line was replaced`);
                    }
                  } else {
                    console.log(`⚠️  Found pattern but couldn't find matching line`);
                  }
                } else {
                  console.log(`⚠️  Could not find unchecked checkbox pattern: ${searchPattern}`);
                }
              } else {
                console.log(`ℹ️  Target checkbox already checked: ${targetCheckboxText}`);
              }
            }
            
            // 2. Auto-fill Related Issue
            if (hasIssue && issueNumber) {
              const issuePattern = /<!-- Closes #\d+ -->/;
              const newIssueLine = `<!-- Closes #${issueNumber} -->`;
              
              if (!body.includes(`#${issueNumber}`)) {
                if (body.includes('<!-- Closes #X -->')) {
                  body = body.replace('<!-- Closes #X -->', newIssueLine);
                } else if (!body.match(issuePattern)) {
                  // Add after "Related Issue" section
                  body = body.replace(
                    /(## Related Issue[^\n]*\n[^\n]*\n)/,
                    `$1${newIssueLine}\n`
                  );
                }
                updated = true;
                console.log(`✅ Auto-filled related issue: #${issueNumber}`);
              }
            }
            
            // 3. Auto-fill Description if empty
            if (body.includes('<!-- Describe what this PR does -->') || 
                body.match(/## Description\s*\n\s*<!--/)) {
              const firstCommit = commitMessages.split('\n')[0] || '';
              let description = '';
              
              if (firstCommit) {
                // Use first commit message, remove type prefix if conventional
                description = firstCommit.replace(/^(feat|fix|docs|chore|refactor|style|test|build|ci|perf|revert)(\(.+\))?:\s*/i, '');
                description = description.charAt(0).toUpperCase() + description.slice(1);
              } else {
                // Fallback to branch description
                description = branchDescription || `Implements ${branchName.replace(/^[^/]+\//, '')}`;
              }
              
              body = body.replace(
                /(## Description\s*\n\s*)<!-- Describe what this PR does -->/,
                `$1${description}`
              );
              updated = true;
              console.log(`✅ Auto-filled description: ${description.substring(0, 50)}...`);
            }
            
            // 4. Auto-check Testing checklist items
            const testingCheckboxes = [
              { pattern: '- [ ] Tested locally', shouldCheck: true }, // Always check if files changed
              { pattern: '- [ ] Documentation preview checked (`npm start`)', shouldCheck: hasMarkdown },
              { pattern: '- [ ] Build passes (`npm run build`)', shouldCheck: true }, // Always runs in CI
              { pattern: '- [ ] Link checks pass (`npm run test:links`)', shouldCheck: hasMarkdown } // Docs need link checks
            ];
            
            for (const item of testingCheckboxes) {
              if (item.shouldCheck && body.includes(item.pattern)) {
                const checked = item.pattern.replace('[ ]', '[x]');
                if (!body.includes(checked)) {
                  body = body.replace(item.pattern, checked);
                  updated = true;
                  console.log(`✅ Auto-checked: ${item.pattern.substring(0, 40)}...`);
                }
              }
            }
            
            // 5. Auto-check Checklist items
            const checklistItems = [
              { pattern: '- [ ] Changes tested locally', shouldCheck: true },
              { pattern: '- [ ] Commit messages are clear and descriptive', shouldCheck: conventionalCommits }
            ];
            
            for (const item of checklistItems) {
              if (item.shouldCheck && body.includes(item.pattern)) {
                const checked = item.pattern.replace('[ ]', '[x]');
                if (!body.includes(checked)) {
                  body = body.replace(item.pattern, checked);
                  updated = true;
                  console.log(`✅ Auto-checked checklist: ${item.pattern.substring(0, 40)}...`);
                }
              }
            }
            
            // Update PR body if anything changed
            if (updated) {
              console.log(`Updating PR #${prNumber} with body length: ${body.length}`);
              console.log(`Body contains '[x] Feature': ${body.includes('[x] Feature')}`);
              try {
                await github.rest.pulls.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                  body: body
                });
                console.log('✅ PR template auto-filled successfully!');
              } catch (error) {
                console.log(`❌ Error updating PR: ${error.message}`);
                throw error;
              }
            } else {
              console.log('ℹ️  PR template already filled or no changes needed');
            }

